(*
    Copyright (c) 2000
        Cambridge University Technical Services Limited
    
    Further development Copyright (c) 2015, 2016 David C.J. Matthews


    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License version 2.1 as published by the Free Software Foundation.
    
    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.
    
    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*)

(*
    Title:      Code Generator Routines.
    Author:     Dave Matthews, Cambridge University Computer Laboratory
    Copyright   Cambridge University 1985
*)

(*
 This module contains the code vector and operations to insert code into
  it. Each procedure is compiled into a separate segment. Initially it is
  compiled into a fixed size segment, and then copied into a segment of the
  correct size at the end.
*)

functor INTCODECONS (
structure DEBUG: DEBUGSIG

structure PRETTY: PRETTYSIG

) : INTCODECONSSIG =

struct
    open CODE_ARRAY
    open DEBUG
    open Address
    open Misc
  
    (* The "enterInt" instruction is only used when porting to a new architecture.  Since
       we only use the interpreted version to support non-X86 architectures we don't need
       to generate them. *)
    val generateEnterInt = false

    (* Typically the compiler is built on a little-endian machine but it could
       be run on a machine with either endian-ness.  We have to find out the
       endian-ness when we run.  There are separate versions of the compiler
       for 32-bit and 64-bit so that can be a constant.  *)
    fun littleEndian () : bool = not (Compat560.isBigEndian())

    val wordLength = Word.toInt RunCall.bytesPerWord
 
    val MAXINTARGS = (* 31 *) 126;

    infix 6 addrPlus addrMinus;

    (* All indexes into the code vector have type "addrs" *)
    (* This should be an abstype, but it's exported as an eqtype *)
    datatype addrs = Addr of int

    (* + is defined to add an integer to an address *)
    fun (Addr a) addrPlus b = Addr (a + b);

    (* The difference between two addresses is an integer *)
    fun (Addr a) addrMinus (Addr b) = a - b; 

    fun mkAddr n = Addr n;    (* addr.up   *)

    fun getAddr (Addr a) = a; (* addr.down *)

    val addrZero = mkAddr 0;

   (* These instructions are only needed during porting between
       interpreted and machine-code versions. The first should be the
       interrupt or break-point instruction of the host machine-code and
       causes the machine to enter the interpreter. It is ignored by the
       interpreter except immediately after the interpreter has been
       entered when result registers may be pushed depending on the
       argument. The second instruction should be a no-op in the machine
       code instruction set and has the reverse effect. It is never
       generated by this code-generator but it is needed in machine-code
       code-generators. 
       Note: indirect forms of jumps are assumed to have the opcode 4
       more than the corresponding direct form.
    *)
    local
        (* Not an abstype, because we we require the equality attribute *)
        datatype opcode = Opcode of int;
    in
    type opcode = opcode;
    fun opcode_down (Opcode n) : int = n;
    fun opcode_up (n : int) : opcode = Opcode n;
    
    val opcode_enterInt          = Opcode 0x00
    and opcode_jump              = Opcode 0x02    (* 8-bit unsigned jump forward. *)
    and opcode_jumpFalse         = Opcode 0x03    (* Test top of stack. Take 8-bit unsigned jump if false. *)
    and opcode_delHandler        = Opcode 0x05
    and opcode_alloc_ref         = Opcode 0x06
    and opcode_jumpIFalse        = Opcode 0x07
    and opcode_delHandlerI       = Opcode 0x09
    and opcode_caseSwitch        = Opcode 0x0a
    and opcode_containerW        = Opcode 0x0b
    and opcode_callClosure       = Opcode 0x0c
    and opcode_returnW           = Opcode 0x0d
    and opcode_pad               = Opcode 0x0e
    and opcode_jumpI             = Opcode 0x0f (* Unsigned indirect jump. *)
    and opcode_raiseEx           = Opcode 0x10
    and opcode_getStoreW         = Opcode 0x11
    and opcode_nonLocal          = Opcode 0x12
    and opcode_localW            = Opcode 0x13
    and opcode_indirectW         = Opcode 0x14
    and opcode_moveToVecW        = Opcode 0x15
    and opcode_setStackValW      = Opcode 0x17
    and opcode_resetW            = Opcode 0x18
    and opcode_resetR_w          = Opcode 0x19
    and opcode_constAddr         = Opcode 0x1a
    and opcode_constIntW         = Opcode 0x1b
    and opcode_jumpBack8         = Opcode 0x1e   (* 8-bit unsigned jump backwards - relative to end of instr. *)
    and opcode_returnB           = Opcode 0x1f
    and opcode_jumpBack16        = Opcode 0x20    (* 16-bit unsigned jump backwards - relative to end of instr. *)
    and opcode_getStoreB         = Opcode 0x21
    and opcode_localB            = Opcode 0x22
    and opcode_indirectB         = Opcode 0x23
    and opcode_moveToVecB        = Opcode 0x24
    and opcode_setStackValB      = Opcode 0x25
    and opcode_resetB            = Opcode 0x26
    and opcode_resetRB           = Opcode 0x27
    and opcode_constIntB         = Opcode 0x28
    and opcode_local_0           = Opcode 0x29
    and opcode_local_1           = Opcode 0x2a
    and opcode_local_2           = Opcode 0x2b
    and opcode_local_3           = Opcode 0x2c
    and opcode_local_4           = Opcode 0x2d
    and opcode_local_5           = Opcode 0x2e
    and opcode_local_6           = Opcode 0x2f
    and opcode_local_7           = Opcode 0x30
    and opcode_local_8           = Opcode 0x31
    and opcode_local_9           = Opcode 0x32
    and opcode_local_10          = Opcode 0x33
    and opcode_local_11          = Opcode 0x34
    and opcode_indirect_0        = Opcode 0x35
    and opcode_indirect_1        = Opcode 0x36
    and opcode_indirect_2        = Opcode 0x37
    and opcode_indirect_3        = Opcode 0x38
    and opcode_indirect_4        = Opcode 0x39
    and opcode_indirect_5        = Opcode 0x3a
    and opcode_const_0           = Opcode 0x3b
    and opcode_const_1           = Opcode 0x3c
    and opcode_const_2           = Opcode 0x3d
    and opcode_const_3           = Opcode 0x3e
    and opcode_const_4           = Opcode 0x3f
    and opcode_const_10          = Opcode 0x40
    and opcode_return_0          = Opcode 0x41
    and opcode_return_1          = Opcode 0x42
    and opcode_return_2          = Opcode 0x43
    and opcode_return_3          = Opcode 0x44
    and opcode_moveToVec_0       = Opcode 0x45
    and opcode_moveToVec_1       = Opcode 0x46
    and opcode_moveToVec_2       = Opcode 0x47
    and opcode_moveToVec_3       = Opcode 0x48
    and opcode_moveToVec_4       = Opcode 0x49
    and opcode_moveToVec_5       = Opcode 0x4a
    and opcode_moveToVec_6       = Opcode 0x4b
    and opcode_moveToVec_7       = Opcode 0x4c
    and opcode_reset_1           = Opcode 0x50
    and opcode_reset_2           = Opcode 0x51
    and opcode_getStore_2        = Opcode 0x52
    and opcode_getStore_3        = Opcode 0x53
    and opcode_getStore_4        = Opcode 0x54
    and opcode_tuple_containerW  = Opcode 0x55
    and opcode_nonLocalL_1       = Opcode 0x56
    and opcode_nonLocalL_2       = Opcode 0x57
    and opcode_nonLocalL_3       = Opcode 0x58
    and opcode_resetR_1          = Opcode 0x64
    and opcode_resetR_2          = Opcode 0x65
    and opcode_resetR_3          = Opcode 0x66
    and opcode_tupleW            = Opcode 0x67
    and opcode_tupleB            = Opcode 0x68
    and opcode_tuple_2           = Opcode 0x69
    and opcode_tuple_3           = Opcode 0x6a
    and opcode_tuple_4           = Opcode 0x6b
    and opcode_lock              = Opcode 0x6c
    and opcode_ldexc             = Opcode 0x6d
    and opcode_pushHandler       = Opcode 0x78
    and opcode_tailbb            = Opcode 0x7b
    and opcode_tail              = Opcode 0x7c
    and opcode_tail3b            = Opcode 0x7d
    and opcode_tail4b            = Opcode 0x7e
    and opcode_tail3_2           = Opcode 0x7f
    and opcode_tail3_3           = Opcode 0x80
    and opcode_setHandler        = Opcode 0x81
    and opcode_setHandlerI       = Opcode 0x82

    and opcode_callFastRTS0      = Opcode 0x83
    and opcode_callFastRTS1      = Opcode 0x84
    and opcode_callFastRTS2      = Opcode 0x85
    and opcode_callFastRTS3      = Opcode 0x86
    and opcode_callFastRTS4      = Opcode 0x87
    and opcode_callFastRTS5      = Opcode 0x88

    and opcode_callFullRTS0      = Opcode 0x89
    and opcode_callFullRTS1      = Opcode 0x8a
    and opcode_callFullRTS2      = Opcode 0x8b
    and opcode_callFullRTS3      = Opcode 0x8c
    and opcode_callFullRTS4      = Opcode 0x8d
    and opcode_callFullRTS5      = Opcode 0x8e

    and opcode_callFastRTSFtoF   = Opcode 0x8f
    and opcode_callFastRTSGtoF   = Opcode 0x90
    
    and opcode_notBoolean        = Opcode 0x91
    and opcode_isTagged          = Opcode 0x92
    and opcode_cellLength        = Opcode 0x93
    and opcode_cellFlags         = Opcode 0x94
    and opcode_clearMutable      = Opcode 0x95
    and opcode_atomicIncr        = Opcode 0x97
    and opcode_atomicDecr        = Opcode 0x98
    and opcode_atomicReset       = Opcode 0x99
    and opcode_longWToTagged     = Opcode 0x9a
    and opcode_signedToLongW     = Opcode 0x9b
    and opcode_unsignedToLongW   = Opcode 0x9c
    and opcode_realAbs           = Opcode 0x9d
    and opcode_realNeg           = Opcode 0x9e
    and opcode_floatFixedInt     = Opcode 0x9f
    
    and opcode_equalWord         = Opcode 0xa0
    and opcode_notequalWord      = Opcode 0xa1
    and opcode_lessSigned        = Opcode 0xa2
    and opcode_lessUnsigned      = Opcode 0xa3
    and opcode_lessEqSigned      = Opcode 0xa4
    and opcode_lessEqUnsigned    = Opcode 0xa5
    and opcode_greaterSigned     = Opcode 0xa6
    and opcode_greaterUnsigned   = Opcode 0xa7
    and opcode_greaterEqSigned   = Opcode 0xa8
    and opcode_greaterEqUnsigned = Opcode 0xa9

    and opcode_fixedAdd          = Opcode 0xaa
    and opcode_fixedSub          = Opcode 0xab
    and opcode_fixedMult         = Opcode 0xac
    and opcode_fixedQuot         = Opcode 0xad
    and opcode_fixedRem          = Opcode 0xae
    and opcode_fixedDiv          = Opcode 0xaf
    and opcode_fixedMod          = Opcode 0xb0
    and opcode_wordAdd           = Opcode 0xb1
    and opcode_wordSub           = Opcode 0xb2
    and opcode_wordMult          = Opcode 0xb3
    and opcode_wordDiv           = Opcode 0xb4
    and opcode_wordMod           = Opcode 0xb5
    and opcode_wordAnd           = Opcode 0xb7
    and opcode_wordOr            = Opcode 0xb8
    and opcode_wordXor           = Opcode 0xb9
    and opcode_wordShiftLeft     = Opcode 0xba
    and opcode_wordShiftRLog     = Opcode 0xbb
    and opcode_wordShiftRArith   = Opcode 0xbc
    and opcode_allocByteMem      = Opcode 0xbd
    and opcode_lgWordEqual       = Opcode 0xbe
    and opcode_lgWordNotequal    = Opcode 0xbf
    and opcode_lgWordLess        = Opcode 0xc0
    and opcode_lgWordLessEq      = Opcode 0xc1
    and opcode_lgWordGreater     = Opcode 0xc2
    and opcode_lgWordGreaterEq   = Opcode 0xc3
    and opcode_lgWordAdd         = Opcode 0xc4
    and opcode_lgWordSub         = Opcode 0xc5
    and opcode_lgWordMult        = Opcode 0xc6
    and opcode_lgWordDiv         = Opcode 0xc7
    and opcode_lgWordMod         = Opcode 0xc8
    and opcode_lgWordAnd         = Opcode 0xc9
    and opcode_lgWordOr          = Opcode 0xca
    and opcode_lgWordXor         = Opcode 0xcb
    and opcode_lgWordShiftLeft   = Opcode 0xcc
    and opcode_lgWordShiftRLog   = Opcode 0xcd
    and opcode_lgWordShiftRArith = Opcode 0xce
    and opcode_realEqual         = Opcode 0xcf
    and opcode_realNotequal      = Opcode 0xd0
    and opcode_realLess          = Opcode 0xd1
    and opcode_realLessEq        = Opcode 0xd2
    and opcode_realGreater       = Opcode 0xd3
    and opcode_realGreaterEq     = Opcode 0xd4
    and opcode_realAdd           = Opcode 0xd5
    and opcode_realSub           = Opcode 0xd6
    and opcode_realMult          = Opcode 0xd7
    and opcode_realDiv           = Opcode 0xd8
    and opcode_getThreadId       = Opcode 0xd9
    and opcode_allocWordMemory   = Opcode 0xda
    and opcode_loadMLWord        = Opcode 0xdb
    and opcode_loadMLByte        = Opcode 0xdc
    and opcode_loadC8            = Opcode 0xdd
    and opcode_loadC16           = Opcode 0xde
    and opcode_loadC32           = Opcode 0xdf
    and opcode_loadC64           = Opcode 0xe0
    and opcode_loadCFloat        = Opcode 0xe1
    and opcode_loadCDouble       = Opcode 0xe2
    and opcode_storeMLWord       = Opcode 0xe3
    and opcode_storeMLByte       = Opcode 0xe4
    and opcode_storeC8           = Opcode 0xe5
    and opcode_storeC16          = Opcode 0xe6
    and opcode_storeC32          = Opcode 0xe7
    and opcode_storeC64          = Opcode 0xe8
    and opcode_storeCFloat       = Opcode 0xe9
    and opcode_storeCDouble      = Opcode 0xea
    and opcode_blockMoveWord     = Opcode 0xeb
    and opcode_blockMoveByte     = Opcode 0xec
    and opcode_blockEqualByte    = Opcode 0xed
    and opcode_blockCompareByte  = Opcode 0xee
    and opcode_loadUntagged      = Opcode 0xef
    and opcode_storeUntagged     = Opcode 0xf0
    and opcode_deleteHandler     = Opcode 0xf1 (* Just deletes the handler - no jump. *)
    and opcode_jump32            = Opcode 0xf2 (* 32-bit signed jump, forwards or backwards. *)
    and opcode_jump32False       = Opcode 0xf3 (* Test top item. Take 32-bit signed jump if false. *)
    and opcode_constAddr32       = Opcode 0xf4 (* Followed by a 32-bit offset. Load a constant at that address. *)
    and opcode_setHandler32      = Opcode 0xf5 (* Setup a handler whose address is given by the 32-bit signed offset. *)
    and opcode_indexedJump       = Opcode 0xf6 (* Indexed jump *)
 
    local
      val repArray : string Array.array = 
        Array.tabulate (256, fn (i : int) => "<UNKNOWN " ^ Int.toString i ^ ">");
      
      fun repUpdate (Opcode n, s) = Array.update (repArray, n, s);

      val () = repUpdate(opcode_enterInt,     "enterInt");
      val () = repUpdate(opcode_jump,         "jump");
      val () = repUpdate(opcode_jumpFalse,    "jumpFalse");
      val () = repUpdate(opcode_delHandler,   "delHandler");
      val () = repUpdate(opcode_alloc_ref,    "alloc_ref");
      val () = repUpdate(opcode_jumpI,        "jumpI");
      val () = repUpdate(opcode_jumpIFalse,   "jumpIFalse");
      val () = repUpdate(opcode_delHandlerI,  "delHandlerI");
      val () = repUpdate(opcode_caseSwitch,   "caseSwitch");
      val () = repUpdate(opcode_callClosure,  "callClosure");
      val () = repUpdate(opcode_returnW,      "returnW");
      val () = repUpdate(opcode_pad,          "pad");
      val () = repUpdate(opcode_raiseEx,      "raiseEx");
      val () = repUpdate(opcode_getStoreW,    "getStoreW");
      val () = repUpdate(opcode_nonLocal,     "nonLocal");
      val () = repUpdate(opcode_localW,       "localW");
      val () = repUpdate(opcode_indirectW,    "indirectW");
      val () = repUpdate(opcode_moveToVecW,   "moveToVecW");
      val () = repUpdate(opcode_setStackValW, "setStackValW");
      val () = repUpdate(opcode_resetW,        "resetW");
      val () = repUpdate(opcode_resetR_w,      "resetR_w");
      val () = repUpdate(opcode_constAddr,     "constAddr");
      val () = repUpdate(opcode_constIntW,     "constIntW");
      val () = repUpdate(opcode_jumpBack8,     "jumpBack8");
      val () = repUpdate(opcode_returnB,       "returnB");
      val () = repUpdate(opcode_jumpBack16,    "jumpBack16");
      val () = repUpdate(opcode_getStoreB,     "getStoreB");
      val () = repUpdate(opcode_localB,        "localB");
      val () = repUpdate(opcode_indirectB,     "indirectB");
      val () = repUpdate(opcode_moveToVecB,    "moveToVecB");
      val () = repUpdate(opcode_setStackValB,  "setStackValB");
      val () = repUpdate(opcode_resetB,        "resetB");
      val () = repUpdate(opcode_resetRB,       "resetRB");
      val () = repUpdate(opcode_constIntB,     "constIntB");
      val () = repUpdate(opcode_local_0,       "local_0");
      val () = repUpdate(opcode_local_1,       "local_1");
      val () = repUpdate(opcode_local_2,       "local_2");
      val () = repUpdate(opcode_local_3,       "local_3");
      val () = repUpdate(opcode_local_4,       "local_4");
      val () = repUpdate(opcode_local_5,       "local_5");
      val () = repUpdate(opcode_local_6,       "local_6");
      val () = repUpdate(opcode_local_7,       "local_7");
      val () = repUpdate(opcode_local_8,       "local_8");
      val () = repUpdate(opcode_local_9,       "local_9");
      val () = repUpdate(opcode_local_10,      "local_10");
      val () = repUpdate(opcode_local_11,      "local_11");
      val () = repUpdate(opcode_indirect_0,    "indirect_0");
      val () = repUpdate(opcode_indirect_1,    "indirect_1");
      val () = repUpdate(opcode_indirect_2,    "indirect_2");
      val () = repUpdate(opcode_indirect_3,    "indirect_3");
      val () = repUpdate(opcode_indirect_4,    "indirect_4");
      val () = repUpdate(opcode_indirect_5,    "indirect_5");
      val () = repUpdate(opcode_const_0,       "const_0");
      val () = repUpdate(opcode_const_1,       "const_1");
      val () = repUpdate(opcode_const_2,       "const_2");
      val () = repUpdate(opcode_const_3,       "const_3");
      val () = repUpdate(opcode_const_4,       "const_4");
      val () = repUpdate(opcode_const_10,      "const_10");
      val () = repUpdate(opcode_return_0,      "return_0");
      val () = repUpdate(opcode_return_1,      "return_1");
      val () = repUpdate(opcode_return_2,      "return_2");
      val () = repUpdate(opcode_return_3,      "return_3");
      val () = repUpdate(opcode_moveToVec_0,   "moveToVec_0");
      val () = repUpdate(opcode_moveToVec_1,   "moveToVec_1");
      val () = repUpdate(opcode_moveToVec_2,   "moveToVec_2");
      val () = repUpdate(opcode_moveToVec_3,   "moveToVec_3");
      val () = repUpdate(opcode_moveToVec_4,   "moveToVec_4");
      val () = repUpdate(opcode_moveToVec_5,   "moveToVec_5");
      val () = repUpdate(opcode_moveToVec_6,   "moveToVec_6");
      val () = repUpdate(opcode_moveToVec_7,   "moveToVec_7");
      val () = repUpdate(opcode_reset_1,       "reset_1");
      val () = repUpdate(opcode_reset_2,       "reset_2");
      val () = repUpdate(opcode_getStore_2,    "getStore_2");
      val () = repUpdate(opcode_getStore_3,    "getStore_3");
      val () = repUpdate(opcode_getStore_4,    "getStore_4");
      val () = repUpdate(opcode_nonLocalL_1,   "nonLocalL_1");
      val () = repUpdate(opcode_nonLocalL_2,   "nonLocalL_2");
      val () = repUpdate(opcode_nonLocalL_3,   "nonLocalL_3");
      val () = repUpdate(opcode_resetR_1,      "resetR_1");
      val () = repUpdate(opcode_resetR_2,      "resetR_2");
      val () = repUpdate(opcode_resetR_3,      "resetR_3");
      val () = repUpdate(opcode_tupleW,        "tupleW");
      val () = repUpdate(opcode_tupleB,        "tupleB");
      val () = repUpdate(opcode_tuple_2,       "tuple_2");
      val () = repUpdate(opcode_tuple_3,       "tuple_3");
      val () = repUpdate(opcode_tuple_4,       "tuple_4");
      val () = repUpdate(opcode_lock,          "lock");
      val () = repUpdate(opcode_ldexc,         "ldexc");
      val () = repUpdate(opcode_setHandler,    "setHandler");
      val () = repUpdate(opcode_pushHandler,   "pushHandler");
      val () = repUpdate(opcode_setHandlerI,   "setHandlerI");
      val () = repUpdate(opcode_tailbb,        "tailbb");
      val () = repUpdate(opcode_tail,          "tail");
      val () = repUpdate(opcode_tail3b,        "tail3b");
      val () = repUpdate(opcode_tail4b,        "tail4b");
      val () = repUpdate(opcode_tail3_2,       "tail3_2");
      val () = repUpdate(opcode_tail3_3,       "tail3_3");
      val () = repUpdate(opcode_callFastRTS0,  "callFastRTS0")
      val () = repUpdate(opcode_callFastRTS1,  "callFastRTS1")
      val () = repUpdate(opcode_callFastRTS2,  "callFastRTS2")
      val () = repUpdate(opcode_callFastRTS3,  "callFastRTS3")
      val () = repUpdate(opcode_callFastRTS4,  "callFastRTS4")
      val () = repUpdate(opcode_callFastRTS5,  "callFastRTS5")
      val () = repUpdate(opcode_callFullRTS0,  "callFullRTS0")
      val () = repUpdate(opcode_callFullRTS1,  "callFullRTS1")
      val () = repUpdate(opcode_callFullRTS2,  "callFullRTS2")
      val () = repUpdate(opcode_callFullRTS3,  "callFullRTS3")
      val () = repUpdate(opcode_callFullRTS4,  "callFullRTS4")
      val () = repUpdate(opcode_callFullRTS5,  "callFullRTS5")
      val () = repUpdate(opcode_callFastRTSFtoF,  "callFullRTSFtoF")
      val () = repUpdate(opcode_callFastRTSGtoF,  "callFullRTSGtoF")
        val () = repUpdate(opcode_notBoolean, "notBoolean")
        val () = repUpdate(opcode_isTagged, "isTagged")
        val () = repUpdate(opcode_cellLength, "cellLength")
        val () = repUpdate(opcode_cellFlags, "cellFlags")
        val () = repUpdate(opcode_clearMutable, "clearMutable")
        val () = repUpdate(opcode_atomicIncr, "atomicIncr")
        val () = repUpdate(opcode_atomicDecr, "atomicDecr")
        val () = repUpdate(opcode_atomicReset, "atomicReset")
        val () = repUpdate(opcode_longWToTagged, "longWToTagged")
        val () = repUpdate(opcode_signedToLongW, "signedToLongW")
        val () = repUpdate(opcode_unsignedToLongW, "unsignedToLongW")
        val () = repUpdate(opcode_realAbs, "realAbs")
        val () = repUpdate(opcode_realNeg, "realNeg")
        val () = repUpdate(opcode_floatFixedInt, "floatFixedInt")

        val () = repUpdate(opcode_equalWord, "equalWord")
        val () = repUpdate(opcode_notequalWord, "notequalWord")
        val () = repUpdate(opcode_lessSigned, "lessSigned")
        val () = repUpdate(opcode_lessUnsigned, "lessUnsigned")
        val () = repUpdate(opcode_lessEqSigned, "lessEqSigned")
        val () = repUpdate(opcode_lessEqUnsigned, "lessEqUnsigned")
        val () = repUpdate(opcode_greaterSigned, "greaterSigned")
        val () = repUpdate(opcode_greaterUnsigned, "greaterUnsigned")
        val () = repUpdate(opcode_greaterEqSigned, "greaterEqSigned")
        val () = repUpdate(opcode_greaterEqUnsigned, "greaterEqUnsigned")

        val () = repUpdate(opcode_fixedAdd, "fixedAdd")
        val () = repUpdate(opcode_fixedSub, "fixedSub")
        val () = repUpdate(opcode_fixedMult, "fixedMult")
        val () = repUpdate(opcode_fixedQuot, "fixedQuot")
        val () = repUpdate(opcode_fixedRem, "fixedRem")
        val () = repUpdate(opcode_fixedDiv, "fixedDiv")
        val () = repUpdate(opcode_fixedMod, "fixedMod")
        val () = repUpdate(opcode_wordAdd, "wordAdd")
        val () = repUpdate(opcode_wordSub, "wordSub")
        val () = repUpdate(opcode_wordMult, "wordMult")
        val () = repUpdate(opcode_wordDiv, "wordDiv")
        val () = repUpdate(opcode_wordMod, "wordMod")
        val () = repUpdate(opcode_wordAnd, "wordAnd")
        val () = repUpdate(opcode_wordOr, "wordOr")
        val () = repUpdate(opcode_wordXor, "wordXor")
        val () = repUpdate(opcode_wordShiftLeft, "wordShiftLeft")
        val () = repUpdate(opcode_wordShiftRLog, "wordShiftRLog")
        val () = repUpdate(opcode_wordShiftRArith, "wordShiftRArith")
        val () = repUpdate(opcode_allocByteMem, "allocByteMem")
        val () = repUpdate(opcode_lgWordEqual, "lgWordEqual")
        val () = repUpdate(opcode_lgWordNotequal, "lgWordNotequal")
        val () = repUpdate(opcode_lgWordLess, "lgWordLess")
        val () = repUpdate(opcode_lgWordLessEq, "lgWordLessEq")
        val () = repUpdate(opcode_lgWordGreater, "lgWordGreater")
        val () = repUpdate(opcode_lgWordGreaterEq, "lgWordGreaterEq")
        val () = repUpdate(opcode_lgWordAdd, "lgWordAdd")
        val () = repUpdate(opcode_lgWordSub, "lgWordSub")
        val () = repUpdate(opcode_lgWordMult, "lgWordMult")
        val () = repUpdate(opcode_lgWordDiv, "lgWordDiv")
        val () = repUpdate(opcode_lgWordMod, "lgWordMod")
        val () = repUpdate(opcode_lgWordAnd, "lgWordAnd")
        val () = repUpdate(opcode_lgWordOr, "lgWordOr")
        val () = repUpdate(opcode_lgWordXor, "lgWordXor")
        val () = repUpdate(opcode_lgWordShiftLeft, "lgWordShiftLeft")
        val () = repUpdate(opcode_lgWordShiftRLog, "lgWordShiftRLog")
        val () = repUpdate(opcode_lgWordShiftRArith, "lgWordShiftRArith")
        val () = repUpdate(opcode_realEqual, "realEqual")
        val () = repUpdate(opcode_realNotequal, "realNotequal")
        val () = repUpdate(opcode_realLess, "realLess")
        val () = repUpdate(opcode_realLessEq, "realLessEq")
        val () = repUpdate(opcode_realGreater, "realGreater")
        val () = repUpdate(opcode_realGreaterEq, "realGreaterEq")
        val () = repUpdate(opcode_realAdd, "realAdd")
        val () = repUpdate(opcode_realSub, "realSub")
        val () = repUpdate(opcode_realMult, "realMult")
        val () = repUpdate(opcode_realDiv, "realDiv")
        val () = repUpdate(opcode_getThreadId, "getThreadId")
        val () = repUpdate(opcode_allocWordMemory, "allocWordMemory")
        val () = repUpdate(opcode_loadMLWord, "loadMLWord")
        val () = repUpdate(opcode_loadMLByte, "loadMLByte")
        val () = repUpdate(opcode_loadC8, "loadC8")
        val () = repUpdate(opcode_loadC16, "loadC16")
        val () = repUpdate(opcode_loadC32, "loadC32")
        val () = repUpdate(opcode_loadC64, "loadC64")
        val () = repUpdate(opcode_loadCFloat, "loadCFloat")
        val () = repUpdate(opcode_loadCDouble, "loadCDouble")
        val () = repUpdate(opcode_storeMLWord, "storeMLWord")
        val () = repUpdate(opcode_storeMLByte, "storeMLByte")
        val () = repUpdate(opcode_storeC8, "storeC8")
        val () = repUpdate(opcode_storeC16, "storeC16")
        val () = repUpdate(opcode_storeC32, "storeC32")
        val () = repUpdate(opcode_storeC64, "storeC64")
        val () = repUpdate(opcode_storeCFloat, "storeCFloat")
        val () = repUpdate(opcode_storeCDouble, "storeCDouble")
        val () = repUpdate(opcode_blockMoveWord, "blockMoveWord")
        val () = repUpdate(opcode_blockMoveByte, "blockMoveByte")
        val () = repUpdate(opcode_blockEqualByte, "blockEqualByte")
        val () = repUpdate(opcode_blockCompareByte, "blockCompareByte")
        val () = repUpdate(opcode_loadUntagged, "loadUntagged")
        val () = repUpdate(opcode_deleteHandler, "deleteHandler")
        val () = repUpdate(opcode_jump32,       "jump32")
        val () = repUpdate(opcode_jump32False,  "jump32False")
        val () = repUpdate(opcode_constAddr32,  "constAddr32")
        val () = repUpdate(opcode_setHandler32, "setHandler32")
    in
      fun repr (Opcode n) : string = Array.sub (repArray, n);
    end;


    local
      val sizeArray : int Array.array = Array.array (256, 1);

      fun sizeUpdate (Opcode n, s) = Array.update (sizeArray, n, s);
      
      val () = sizeUpdate(opcode_enterInt    , 2);
      val () = sizeUpdate(opcode_jump        , 2);
      val () = sizeUpdate(opcode_jumpFalse   , 2);
      val () = sizeUpdate(opcode_delHandler  , 2);
      val () = sizeUpdate(opcode_jumpIFalse  , 2);
      val () = sizeUpdate(opcode_delHandlerI , 2);
      val () = sizeUpdate(opcode_caseSwitch  , 3);
      val () = sizeUpdate(opcode_returnW     , 3);
      val () = sizeUpdate(opcode_getStoreW   , 3);
      val () = sizeUpdate(opcode_nonLocal    , 7);
      val () = sizeUpdate(opcode_localW      , 3);
      val () = sizeUpdate(opcode_indirectW   , 3);
      val () = sizeUpdate(opcode_moveToVecW  , 3);
      val () = sizeUpdate(opcode_setStackValW, 3);
      val () = sizeUpdate(opcode_resetW      , 3);
      val () = sizeUpdate(opcode_resetR_w    , 3);
      val () = sizeUpdate(opcode_constAddr   , 3);
      val () = sizeUpdate(opcode_constIntW   , 3);
      val () = sizeUpdate(opcode_jumpBack8   , 2);
      val () = sizeUpdate(opcode_returnB     , 2);
      val () = sizeUpdate(opcode_jumpBack16  , 3);
      val () = sizeUpdate(opcode_getStoreB   , 2);
      val () = sizeUpdate(opcode_localB      , 2);
      val () = sizeUpdate(opcode_indirectB   , 2);
      val () = sizeUpdate(opcode_moveToVecB  , 2);
      val () = sizeUpdate(opcode_setStackValB, 2);
      val () = sizeUpdate(opcode_resetB      , 2);
      val () = sizeUpdate(opcode_resetRB     , 2);
      val () = sizeUpdate(opcode_constIntB   , 2);
      val () = sizeUpdate(opcode_nonLocalL_1 , 2);
      val () = sizeUpdate(opcode_nonLocalL_2 , 2);
      val () = sizeUpdate(opcode_nonLocalL_3 , 2);
      val () = sizeUpdate(opcode_tupleW      , 3);
      val () = sizeUpdate(opcode_tupleB      , 2);
      val () = sizeUpdate(opcode_setHandler  , 2);
      val () = sizeUpdate(opcode_setHandlerI , 2);
      val () = sizeUpdate(opcode_tailbb      , 3);
      val () = sizeUpdate(opcode_tail        , 5);
      val () = sizeUpdate(opcode_tail3b      , 2);
      val () = sizeUpdate(opcode_tail4b      , 2);
        val () = sizeUpdate(opcode_jump32,       5)
        val () = sizeUpdate(opcode_jump32False,  5)
        val () = sizeUpdate(opcode_constAddr32,  5)
        val () = sizeUpdate(opcode_setHandler32, 5)
    in
      fun size (Opcode n) : int = Array.sub (sizeArray, n);
    end;
    end (* opcode abstype *)

    (* The addrs is the address of the branch instruction, so we can fix up
       the branch later, NOT the address we're branching to, which we
       don't know when we generate the label. The cacheState indicates whether
       what was cached at the source of the jump.
     *)
    datatype jumpFrom =
        Jump8From  of addrs  (* branch instruction has  8-bit offset field *)
    |   Jump16From of addrs (* branch instruction has 16-bit offset field *)
    |   Jump32From of addrs (* branch instruction has 32-bit offset field. *)

    (* We need a jumpFrom ref, because we may have to indirect short branches
        via long branches if the offset won't fit into 14 bits *)
    type labels = (jumpFrom ref) list;
  
    val noJump : labels = []; 
  
  (* This is the list of outstanding labels.  Use a separate type from
      "labels" for extra security. *)
  type labList = (jumpFrom ref) list;

(*****************************************************************************)
(*                  The main "code" datatype                                 *)
(*****************************************************************************)

  datatype const =
     WVal of machineWord        (* an existing constant *)

  and setCodeseg =
     Unset
   | Set of cseg   (* Used for completing forward references. *)

  and code = Code of 
    { codeVec:        cseg,           (* This segment is used as a buffer. When the
                                         procedure has been code generated it is
                                         copied into a new segment of the correct size *)
      ic:             addrs ref,      (* Pointer to first free location in "codevec" *)
      constVec:       const list ref, (* Vector of words to be put at end *)
      numOfConsts:    int ref,        (* size of constVec *)
      stackReset:     int ref,        (* Distance to reset the stack before the next instr. *)
      carry:          bool ref,       (* Should a value be moved down if stackReset <> 0? *)

      procName:       string,         (* Name of the procedure. *)
      resultSeg:      setCodeseg ref, (* The segment as the final result. *)
      constLoads:     (addrs * int) list ref, (* where do we load constants? *)
      printAssemblyCode:bool,            (* Whether to print the code when we finish. *)
      printStream:    string->unit    (* The stream to use *)
    };

(*****************************************************************************)
(*                  Auxiliary functions on "code"                            *)
(*****************************************************************************)

  fun codeVec        (Code {codeVec,...})          = codeVec;
  fun ic             (Code {ic,...})               = ic;
  fun constVec       (Code {constVec,...})         = constVec;
  fun numOfConsts    (Code {numOfConsts,...})      = numOfConsts;
  fun stackReset     (Code {stackReset ,...})      = stackReset;
  fun carry          (Code {carry,...})            = carry;
  fun procName       (Code {procName,...})         = procName;
  fun resultSeg      (Code {resultSeg,...})        = resultSeg;
  fun constLoads     (Code {constLoads,...})       = constLoads;

  fun scSet (Set x) = x | scSet _ = raise Match;

  val codesize = 32; (* bytes. Initial size of segment. *)

  fun sameConst (WVal w1, WVal w2) = wordEq (w1, w2)

  (* create and initialise a code segment *)
  fun codeCreate (name : string, parameters) : code = 
  let
    val words : int = codesize div wordLength
    val printStream = PRETTY.getSimplePrinter(parameters, []);
  in
    Code
      { 
         codeVec          = csegMake(Word.fromInt words), (* a byte array *)
         ic               = ref addrZero,
         constVec         = ref [],
         numOfConsts      = ref 0,
         stackReset       = ref 0, (* stack adjustment in WORDs *)
         carry            = ref false,
         procName         = name,
         resultSeg        = ref Unset,   (* Not yet done *)
         constLoads       = ref [],
         printAssemblyCode = DEBUG.getParameter DEBUG.assemblyCodeTag parameters,
         printStream    = printStream
      }
  end;

    fun setLong (value : int, Addr a : addrs, seg : cseg) =
    let
        fun putBytes(value, a, seg, i) =
        if i = wordLength then ()
        else
        (
            csegSet(seg,
                Word.fromInt(if littleEndian() then a+i else a+wordLength-i-1),
                Word8.fromInt(value mod 256));
            putBytes(value div 256, a, seg, i+1)
        )
    in
        putBytes(value, a, seg, 0)
    end

  fun putByte (ival: int, Addr a, cvec: code) =
    csegSet(codeVec cvec, Word.fromInt a, Word8.fromInt (if ival < 0 then 256 + ival else ival));

  fun genByte (ival: int, cvec: code) = 
  let
    val icVal : addrs = ! (ic cvec);
    val () = putByte (ival, icVal, cvec);
  in
    ic cvec := icVal addrPlus 1
  end;
   
  fun genBytes (ival: int, length: int, cvec: code) =
  let
    val () = genByte (ival mod 256, cvec);
  in
    if length = 1 then ()
    else genBytes (ival div 256, length - 1, cvec)
  end;

  fun genWord (ival : int, cvec : code) =
    genBytes (ival, 2, cvec);

    (* puts "length" bytes of "val" into locations "addr", "addr"+1... *)
    fun putBytes (_, 0, _, _) = ()
    |   putBytes (ival, length, addr, cvec) =
        (
            putByte (ival mod 256, addr, cvec);
            putBytes (ival div 256, length - 1, addr addrPlus 1, cvec)
        )

  fun getByte (Addr a, cvec : code) : int =
    Word8.toInt (csegGet(codeVec cvec, Word.fromInt a));

  (* Gets "length" bytes from locations "addr", "addr"+1...
     Returns an unsigned number. *)
  fun getB (length : int, addr : int, seg: cseg) : int =
  let
    val byte = Word8.toInt (csegGet (seg, Word.fromInt addr));
  in
    if length = 1 (* Top byte *)
    then byte
    else let
      val rest = getB (length - 1, addr + 1, seg);
    in
      rest * 256 + byte
    end
  end;

  fun getBytes (length: int, Addr a, cvec : code) : int =
    getB (length, a, codeVec cvec);

  fun resetSp (cvec: code) =
  let 
    val offset = !(stackReset cvec);

    val () =
      if offset < 0
        then raise InternalError ("resetSp: bad reset value " ^ Int.toString offset)
      
      else if offset = 0
        then ()
     
      else if 255 <= offset
        then let
          val opc = if !(carry cvec) then opcode_resetR_w else opcode_resetW;
          val () = genByte (opcode_down opc, cvec);
        in
          genWord (offset, cvec)
        end
         
      else if !(carry cvec)
    then if 3 < offset
      then let
        val () = genByte (opcode_down opcode_resetRB, cvec);
      in
        genByte (offset, cvec)
      end
      else let
        val opc : int = opcode_down opcode_resetR_1 + offset - 1;
      in
        genByte(opc, cvec)
      end
    
      else if 2 < offset
    then let
      val () = genByte (opcode_down opcode_resetB, cvec);
    in
      genByte (offset, cvec)
    end
    else let
      val opc : int = opcode_down opcode_reset_1 + offset - 1;
    in
      genByte(opc, cvec)
    end
  in
    stackReset cvec := 0
  end; (* resetSp *)

    fun fixupOffset (Jump8From addr, target, cvec) =
        let
            (* Offsets are calculated from the END of the instruction, which explains the "+ 1" *)
            val newOffset : int = target addrMinus (addr addrPlus 1);
    
            val () = 
                if 0 <= newOffset andalso newOffset < 256 then ()
                else raise InternalError "fixupOffset: jump too far (8-bit offset)"
    
            val oldOffset : int = getByte (addr, cvec);
    
            val () = 
                if oldOffset = 0 then ()
                else raise InternalError "fixupOffset: 8-bit branch already fixed up"
        in
            putByte (newOffset, addr, cvec)
        end

    |   fixupOffset (Jump16From addr, target, cvec) =
        let
            (* Offsets are calculated from the END of the instruction, which explains the "+ 2" *)
            val newOffset = target addrMinus (addr addrPlus 2);
    
            val () =
                (* Jumps are unsigned. *)
                if 0 <= newOffset andalso newOffset < 65536 then ()
                else raise InternalError "fixupOffset: jump too far (16-bit offset)"
    
            val oldOffset = getBytes (2, addr, cvec);

            val () = 
                if oldOffset = 0 then ()
                else raise InternalError "fixupOffset: 16-bit branch already fixed up"
        in
            putBytes (newOffset, 2, addr, cvec)
        end

    |   fixupOffset (Jump32From addr, target, cvec) =
        let
            (* Offsets are calculated from the END of the instruction, which explains the "+ 4" *)
            val newOffset = target addrMinus (addr addrPlus 4)    
            val oldOffset = getBytes (4, addr, cvec);

            val () = 
                if oldOffset = 0 then ()
                else raise InternalError "fixupOffset: 32-bit branch already fixed up"
        in
            putBytes (newOffset, 4, addr, cvec)
        end


    fun fixup ([], _)  = ()
    |   fixup (lab, cvec) =
    let
        (* Deal with any pending resets. *)
        val () = resetSp cvec
        val target = ! (ic cvec)
    in
        List.app (fn (ref jf) => fixupOffset (jf, target, cvec)) lab
    end;
    
    fun makeLongLabel addr = [ref (Jump32From addr)]

    fun linkLabels (lab1 : labels, lab2 : labels, _ : code) : labels = lab1 @ lab2;

    (* Put in the opcode for an instruction. *)
    fun genOpc (opc, _, cvec) = (resetSp cvec; genByte (opcode_down opc, cvec))
  
    fun genOpcode (oper, code) = genOpc(oper, 1, code)

  fun genRaiseEx (cvec: code) =
    genOpc (opcode_raiseEx, 1, cvec);
  
  fun genLock(cvec: code) =
    genOpc (opcode_lock, 1, cvec);
  
  fun genLdexc (cvec: code) =
    genOpc (opcode_ldexc, 1, cvec);

  fun genPushHandler (cvec: code) =
    genOpc (opcode_pushHandler, 1, cvec);

  (* Generate word, byte or single opcodes. The values from ``f''  to ``l''
     are packed into the opcode by generating opF, opF+1, ... opF+(l-f).
     Other arguments which will fit into a byte generate opB followed by
     the argument. The rest require opW and a word argument. *)
  fun gen1 (opW: opcode, opB: opcode, opF: opcode,
        first : int, last : int, arg1: int, cvec: code) =
        
    if (first <= arg1 andalso arg1 <= last)
    then genOpc (opcode_up (opcode_down opF + arg1 - first), 1, cvec)

    else if 0 <= arg1 andalso arg1 <= 254 (* why not 255? *)
    then let
      val () = genOpc(opB, 2, cvec);
    in
      genByte(arg1, cvec)
    end

    else let
      val () = genOpc(opW, 3, cvec);
    in
      genWord(arg1, cvec)
    end;

  fun genReturn (arg1 : int, cvec : code) =
    gen1 (opcode_returnW,
      opcode_returnB,
      opcode_return_0,
      0, 3, arg1, cvec)

  fun genLocal (arg1 : int, cvec : code) =
    gen1 (opcode_localW, 
      opcode_localB, 
      opcode_local_0,
      0, 11, arg1, cvec);

  fun genIndirect (arg1 : int, cvec : code) =
    gen1 (opcode_indirectW, 
      opcode_indirectB,
      opcode_indirect_0,
      0, 5, arg1, cvec);

  fun genMoveToVec (arg1 : int, cvec : code) =
    gen1 (opcode_moveToVecW,
      opcode_moveToVecB,
      opcode_moveToVec_0,
      0, 7, arg1, cvec);

  fun genSetStackVal (arg1 : int, cvec : code) =
    gen1 (opcode_setStackValW,
      opcode_setStackValB,
      opcode_setStackValB, (* Don't care - no "implied" form exists *)
      1, 0, arg1, cvec);

  fun genTuple (arg1: int, cvec: code) =
    gen1 (opcode_tupleW,
      opcode_tupleB,
      opcode_tuple_2,
      2, 4, arg1, cvec)

    fun genEnterInt (cvec: code, args: int) =
    if generateEnterInt
    then
    (
        genByte(opcode_down opcode_enterInt, cvec);
        genByte(args + 1, cvec)
    )
    else ()

  fun genEnterIntCall (cvec: code, args: int) =
  let
    val () =
      if args < MAXINTARGS then ()
      else raise InternalError "genEnterIntCall: too many arguments";
  in
    genEnterInt(cvec, args)
  end;

  local
    val enterHandlerCode = (*2 * MAXINTARGS *) 254;
  in
    fun genEnterIntCatch (cvec: code) =
      genEnterInt(cvec, enterHandlerCode);
  end;

  fun genEnterIntProc (cvec: code, args: int) =
  let
    val () =
      if args < MAXINTARGS then ()
      else raise InternalError "genEnterIntProc: too many arguments";
      
    val argCode : int = MAXINTARGS + args; 
  
    (* Primary entry point (address 0) *)
    val () = genEnterInt(cvec, argCode);
  in
    ()
  end;

    (* Used for jump, jumpFalse, setHandler and delHandler. *)
    datatype jumpTypes = Jump | JumpFalse | SetHandler

    fun putBranchInstruction (SetHandler, cvec) =
        (
            genOpc (opcode_setHandler32, 5, cvec);
            genBytes (0, 4, cvec);
            makeLongLabel (!(ic cvec) addrPlus ~4)
        )

    |   putBranchInstruction (JumpFalse, cvec) =
        (
            genOpc (opcode_jump32False, 5, cvec);
            genBytes (0, 4, cvec);
            makeLongLabel (!(ic cvec) addrPlus ~4)
        )
    
    |   putBranchInstruction (Jump, cvec) =
        (
            genOpc (opcode_jump32, 5, cvec);
            genBytes (0, 4, cvec);
            makeLongLabel (!(ic cvec) addrPlus ~4)
        )

    fun genCase (nCases, cvec) =
    (
        genOpc (opcode_indexedJump, 3, cvec);
        genWord (nCases, cvec);
        List.tabulate(nCases, fn _ => putBranchInstruction(Jump, cvec))
    )
    
    type backJumpLabel = addrs
    fun setBackJumpLabel (code as Code {ic, ...}) = (resetSp code; !ic)

    (* Always generate a 32-bit jump at the moment *)
    fun jumpback (lab: backJumpLabel, cvec: code) =
    let
        val () = resetSp cvec;
        val newOffset = lab addrMinus (!(ic cvec) addrPlus 5)
        val _ = newOffset < 0 orelse raise InternalError "jumpback"
    in
        genOpc(opcode_jump32, 5, cvec);
        genBytes (newOffset, 4, cvec)
    end

    fun genRTSCallFast(0, cvec) = genOpc (opcode_callFastRTS0, 1, cvec)
    |   genRTSCallFast(1, cvec) = genOpc (opcode_callFastRTS1, 1, cvec)
    |   genRTSCallFast(2, cvec) = genOpc (opcode_callFastRTS2, 1, cvec)
    |   genRTSCallFast(3, cvec) = genOpc (opcode_callFastRTS3, 1, cvec)
    |   genRTSCallFast(4, cvec) = genOpc (opcode_callFastRTS4, 1, cvec)
    |   genRTSCallFast(5, cvec) = genOpc (opcode_callFastRTS5, 1, cvec)
    |   genRTSCallFast(_, _) = raise InternalError "genRTSFastCall"

    fun genRTSCallFull(0, cvec) = genOpc (opcode_callFullRTS0, 1, cvec)
    |   genRTSCallFull(1, cvec) = genOpc (opcode_callFullRTS1, 1, cvec)
    |   genRTSCallFull(2, cvec) = genOpc (opcode_callFullRTS2, 1, cvec)
    |   genRTSCallFull(3, cvec) = genOpc (opcode_callFullRTS3, 1, cvec)
    |   genRTSCallFull(4, cvec) = genOpc (opcode_callFullRTS4, 1, cvec)
    |   genRTSCallFull(5, cvec) = genOpc (opcode_callFullRTS5, 1, cvec)
    |   genRTSCallFull(_, _) = raise InternalError "genRTSCallFull"
    
    fun genRTSCallFastFloatFloat cvec = genOpc (opcode_callFastRTSFtoF, 1, cvec)
    and genRTSCallFastGeneralFloat cvec = genOpc (opcode_callFastRTSGtoF, 1, cvec)

    local
        fun fixupConstantLoad (constStartAddrs, cvec) (fixupAddr, constNum) =
        let
            val oldOffset = getBytes (2, fixupAddr, cvec)
            val _ = oldOffset = 0 orelse raise InternalError "fixupConstantLoad: already fixed-up"

            val constAddr = constStartAddrs addrPlus (wordLength * (constNum+4))
          
            (* Offsets are calculated from the END of the instruction, which explains the "+ 4" *)
            val newOffset = constAddr addrMinus (fixupAddr addrPlus 4)
        in
            putBytes (newOffset, 4, fixupAddr, cvec)
        end
    in
        fun fixupConstantLoads (cvec, constStartAddrs, loadInfo) =
            List.app (fixupConstantLoad (constStartAddrs, cvec)) loadInfo
    end


    (* Find the offset in the constant area of a constant. *)
    (* The first has offset 0.                             *)
    fun addConstToVec (valu : const, cvec : code) : int =
    let
        (* Search the list to see if the constant is already there. *)
        fun findConst valu [] num =
            (* Add to the list *)
            (
                numOfConsts cvec := ! (numOfConsts cvec) + 1;
                constVec cvec    := ! (constVec cvec) @ [valu];
                num
            )
        |   findConst valu (h :: t) num =
                if sameConst (valu, h)
                then num
                else findConst valu t (num + 1) (* Not equal *)
    in
        findConst valu (! (constVec cvec)) 0
    end

    fun genConstRef (constNum : int, cvec : code) =
    let
        (* Remember address of the indirection so we can fix it up later *)
        val fixupAddrs : addrs = !(ic cvec)
    in
        genBytes (0, 4, cvec);
        constLoads cvec := (fixupAddrs, constNum) :: !(constLoads cvec)
    end

    fun pushConst (value : machineWord, cvec : code) =
        if isShort value andalso toShort value < 0w32768
        then
        let
            val iVal: int = Word.toInt (toShort value);
        in
            if iVal = 10
            then genOpc (opcode_const_10, 1, cvec)
      
            else if iVal <= 4
            then genOpc (opcode_up (opcode_down opcode_const_0 + iVal), 1, cvec)
  
            else if iVal < 256
            then (genOpc (opcode_constIntB, 2, cvec); genByte (iVal, cvec))
      
            else ( genOpc (opcode_constIntW, 3, cvec); genWord (iVal, cvec))
        end

        else
        let (* address or large short *)
            val constNum = addConstToVec (WVal value, cvec);
        in
            genOpc (opcode_constAddr32, 5, cvec);
            genConstRef (constNum, cvec)
        end

    fun genCallClosure (cvec: code) = genOpc (opcode_callClosure, 1, cvec)
    
    fun genTailCall (toslide : int, slideby: int, cvec: code) =
    if toslide < 256 andalso slideby < 256
    then case (toslide, slideby) of
        (3, 2) =>  genOpc (opcode_tail3_2, 1, cvec)
           
    |   (3, 3) => genOpc (opcode_tail3_3, 1, cvec)
           
    |   (3, _) => 
        let
            val () = genOpc (opcode_tail3b, 2, cvec);
        in
            genByte (slideby, cvec)
        end
           
    |   (4, _) => 
        let
            val () = genOpc (opcode_tail4b, 2, cvec);
        in
            genByte (slideby, cvec)
        end
           

    |   (_, _) => 
        let (* General byte case *)
            val () = genOpc (opcode_tailbb, 3, cvec);
            val () = genByte (toslide, cvec);
        in
            genByte (slideby, cvec)
        end
           
    else
    let (* General case. *)
        val () = genOpc (opcode_tail, 5, cvec);
        val () = genWord (toslide, cvec);
    in
         genWord(slideby, cvec)
    end; (* genTailCall *)

  fun genContainer (size : int, cvec: code) =
    (genOpc(opcode_containerW, 3, cvec); genWord(size, cvec));

  fun genTupleFromContainer (size : int, cvec: code) =
    (genOpc(opcode_tuple_containerW, 3, cvec); genWord(size, cvec));


  (* Adds in the reset. *)
  fun resetStack (offset : int, carryValue : bool, cvec : code) =
  let
    val () =
      if 0 < offset then ()
      else raise InternalError ("resetStack: bad offset " ^ Int.toString offset);
  
    val () = stackReset cvec := !(stackReset cvec) + offset;
  in
     carry cvec := carryValue
  end;

    fun printCode (seg: cseg, procName: string, endcode : int, printStream) =
    let
        val () = printStream "\n";
        val () = if procName = "" (* No name *) then printStream "?" else printStream procName;
        val () = printStream ":\n";

        (* prints a string representation of a number *)
        fun printHex (v : int) = printStream(Int.fmt StringCvt.HEX v);
 
        val ptr = ref 0;
 
        (* To make sure we do not print branch extensions as though they
           were instructions we keep a list of all indirect forward references
           and print values at those addresses as addresses.
           This list is sorted with the lowest address first. *)
 
        val indirections : int list ref = ref [];
 
        local
            fun addL (n, [] : int list) : int list = [n]
            |   addL (n, l as (x :: xs)) =
                    if n < x then n :: l
                    else if n = x then l
                    else x :: addL (n, xs)
        in
            fun addInd (ind : int) = indirections := addL (ind, !indirections)
        end
 
        (* Prints a relative address. *)
        fun printDisp (len: int, spacer: string, addToList: bool) =
        let
            val ad : int = getB(len, !ptr, seg) + !ptr + len;
            val () = if addToList then addInd ad else ();
            val () = printStream spacer;
            val () = printHex ad;
        in
            ptr := !ptr + len
        end

        (* Prints an operand of an instruction *)
        fun printOp (len: int, spacer : string) =
        let
            val () = printStream spacer;
            val () = printHex (getB (len, !ptr, seg));
        in
            ptr := !ptr + len
        end;

    in
        while !ptr < endcode do
        let
            val addr : int = !ptr
        in
            printHex addr; (* The address. *)

            if (case !indirections of v :: _ => v = addr | [] => false)
            then
            let (* It's an address. *)
                val () = printDisp (2, "\t", false);
            in
                case !indirections of
                    _ :: vs => indirections := vs
                |   _       => raise InternalError "printCode: indirection list confused"
            end
      
            else
            let (* It's an instruction. *)
                val ()  = printStream "\t";
                val opc : opcode = opcode_up (Word8.toInt (csegGet (seg, Word.fromInt (!ptr)))); (* opcode *)
                val ()  = ptr := !ptr + 1;
                val ()  = printStream (repr opc);

                val sz : int = size opc;
            in
                if sz = 1 then ()
    
                else if opc = opcode_jump orelse
                     opc = opcode_jumpFalse orelse
                     opc = opcode_setHandler orelse
                     opc = opcode_delHandler orelse
                     opc = opcode_constAddr
                then printDisp (sz - 1, "\t", false)
    
                else if opc = opcode_jumpI orelse
                        opc = opcode_jumpIFalse orelse
                        opc = opcode_setHandlerI orelse
                        opc = opcode_delHandlerI
                then printDisp (1, "\t", true)
      
                else if opc = opcode_jumpBack8 (* Should be negative *)
                then
                (
                    printStream "\t";
                    printHex((!ptr - 1) - getB(1,!ptr,seg));
                    ptr := !ptr + 1
                )

                else if opc = opcode_jumpBack16 (* Should be negative *)
                then
                (
                    printStream "\t";
                    printHex((!ptr - 1) - getB(2,!ptr,seg));
                    ptr := !ptr + 2
                )
     
                else if opc = opcode_nonLocal
                then ( printOp (2, "\t"); printOp (2, ","); printOp(2, ","))

                else if opc = opcode_caseSwitch
                then
                let
                    (* Have to find out how many items there are. *)
                    val limit : int = getB (2, !ptr, seg);
                    val () = printOp (2, "\t");
                    val base : int = !ptr;
        
                    fun printEntry _ = (printStream "\n\t"; printHex(base + getB(2, !ptr, seg)); ptr := !ptr + 2)
        
                    fun forLoop f i n = if i > n then () else (f i; forLoop f (i + 1) n)
                in
                    forLoop printEntry 0 limit
                end
         
                else if opc = opcode_tail
                then (printOp (2, "\t"); printOp (2, ","))
         
                else if opc = opcode_tailbb
                then (printOp (1, "\t"); printOp (1, ","))
         
                else printOp (sz - 1, "\t")
            end; (* an instruction. *)

            printStream "\n"
        end (* main loop *)
    end (* printCode *)

    (* The count of the number of constants is an untagged value so we can't use loadWord. *)
    fun loadConstCount (a : address, offset : int) : int =
    let
        val byteOffset : int = wordLength * offset
        fun loadBytes (i: int) (acc: int) : int =
        if i = wordLength then acc
        else
        let
            val addr: int =
                if littleEndian() then byteOffset + wordLength - i - 1
                else byteOffset + i;
            val b = loadByte (a, Word.fromInt addr);
            val acc' = acc*256 + Word8.toInt b
        in
            loadBytes (i+1) acc'
        end
    in
        loadBytes 0 0
    end
  
    (* Bootstrapping problems currently prevent us from using Address.nameOfCode.  Has this been fixed?? *)
    fun nameOfCode (a : address) =
    let
        val objLength = Word.toInt (Address.length a);
        val lastWord = objLength - 1;
        val constCount= loadConstCount (a, lastWord);
        val codeName = loadWord (a, Word.fromInt (lastWord - constCount));
    in
        RunCall.unsafeCast codeName
    end

    (* prints a string representation of a number *)
    fun printHex (v : int, printStream) = printStream(Int.fmt StringCvt.HEX v);

    fun printConstCode (a : address, printStream) = printStream ("code:\t" ^ nameOfCode a);
  
    fun printConstClosure (a : address, printStream) = printStream ("clos:\t" ^ nameOfCode a);
  
    fun printWords (a : address, printStream) =
    let
        val objLength : int = Word.toInt (Address.length a)
    in
        if objLength = 1
        then printStream ("long:\t1 word")
        else printStream ("long:\t" ^ Int.toString objLength ^ " words")
    end
  
    fun printBytes (a : address, printStream) =
    let
        val objLength  : int = Word.toInt (Address.length a)
    in
        if objLength = 1
        then printStream ("bytes:\t1 word")
        else printStream ("bytes:\t" ^ Int.toString objLength ^ " words")
    end;

    fun printConst (WVal w : const, printStream) =
    if isShort w
    then
    let
        val value : int = Word.toInt (toShort w)
    in
        printStream "short:\t";
        printHex(value, printStream);
        printStream " (";
        printStream (Int.toString value);
        printStream ")"
    end
    else
    let
        val a = toAddress w
    in
        if isCode a
        then printConstCode(a, printStream)
        else if isBytes a
        then printBytes(a, printStream)
        else if isWords a andalso 0w1 <= Address.length a
        then
        let
            val w' = loadWord (a, 0w0)
        in
            if not (isShort w')
            then
            let
                val a' = toAddress w'
            in
                if isCode a'
                then printConstClosure(a', printStream)
                else printWords(a, printStream) (* First element of tuple is not a code segment *) 
            end
            else printWords(a, printStream) (* First element of tuple is a short *)
        end
        else printWords(a, printStream) (* Not a proper tuple (shouldn't occur) *)
    end
           
    fun printConstants (_    : int, [] : const list, _) = ()
    |   printConstants (addr : int, h :: t, printStream) =
        (
            printHex(addr, printStream);
            printStream "\t";
            printConst(h, printStream);
            printConstants (addr + wordLength, t, printStream)
        )

    (* set the num'th constant in cvec to be value *)
    fun constLabels (cvec : code, num : int, value : machineWord) =
    let
        val seg       = scSet (!(resultSeg cvec));
        (* The +2 in the next instruction is because ic is always the byte count of
           the word after the marker word.  We need to skip over the function name
           and the profile count. *)
        val constAddr = (getAddr (!(ic cvec))) div wordLength + num + 2;
    in
        csegPutWord (seg, Word.fromInt constAddr, value)
    end

    (* Adds the constants onto the code, and copies the code into a new segment *)
    fun copyCode (cvec: code as Code{ printAssemblyCode, printStream, ...}) : address =
    let
        (* Pad out to long word boundary. Don't just leave as zero because, if
           the last instruction (return) had a zero argument, this could give
           a whole word of zero, which would mess up the garbage-collector. 
        *)
        val alignTo = wordLength
        val () = 
            while (getAddr (! (ic cvec)) mod alignTo) <> 0
            do genByte (opcode_down opcode_pad, cvec);

        (* This also aligns ic onto a fullword boundary. *)
        val endIC    = !(ic cvec); (* Remember end *)
        val () = genBytes (0, wordLength, cvec) (* Marker *)

        (* +4 for code size, profile count, function name and constants count *)
        val numOfConst = !(numOfConsts cvec)
        val endOfCode : int = getAddr (! (ic cvec)) div wordLength
        val segSize   : int = endOfCode + numOfConst + 4

        (* fix-up all the constant loads (or indirections) *)
        val () = fixupConstantLoads (cvec, endIC, !(constLoads cvec))

        (* Now make the byte segment that we'll turn into the code segment *)
        val seg : cseg = csegMake(Word.fromInt segSize)
        val ()   = resultSeg cvec := Set seg
    
        (* Copy the code into the new segment. *)
        val () = csegCopySeg (codeVec cvec, seg, Word.fromInt(getAddr (!(ic cvec))), 0w0);

        (* Byte offset of start of code. *)
        local
            val byteEndOfCode = endOfCode * wordLength
            val addr = mkAddr byteEndOfCode
        in
            val () = setLong (byteEndOfCode, addr, seg);
        end;
    
        (* Put in the number of constants. This must go in before
           we actually put in any constants. *)
        local
            val addr = mkAddr ((segSize - 1) * wordLength)
        in
            val () = setLong (numOfConst + 1, addr, seg) 
        end
    
        (* Next the profile count. *)
        local
            val addr = mkAddr ((endOfCode + 1) * wordLength);
        in
            val () = setLong (0, addr, seg) 
        end;

        (* Now we've filled in all the C integers; now we need to convert the segment
          into a proper code segment before it's safe to put in any ML values. *)
        val () = csegConvertToCode seg;

        local
            val name     : string = procName cvec
            val nameWord : machineWord = toMachineWord name
        in
            val () = csegPutWord (seg, Word.fromInt endOfCode + 0w2, nameWord)
        end;


        (* and then copy the objects from the constant list. *)
        fun putLocalConsts []      _ = ()
        |   putLocalConsts (WVal w::cs) num =
                (constLabels (cvec, num, w); putLocalConsts cs (num + 1))
    
        val () = putLocalConsts (! (constVec cvec)) 1;

        val () = 
            if printAssemblyCode
            then
            let (* print out the code *)
                val () = printCode (seg, procName cvec, getAddr endIC, printStream);
                (* Skip: byte offset of start of code segment, 
                     number of constants,
                     profiling word,
                     name of code segment
                *)
                val constants : const list = ! (constVec cvec);
                val () = printConstants (getAddr endIC + 4*wordLength, constants, printStream);
            in
                printStream"\n"
            end
        else ();
    in
        csegLockAndGetExecutable seg
    end (* copyCode *)

end;

